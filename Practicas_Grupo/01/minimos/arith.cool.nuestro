#name "arith.cool"
 OBJECTID contribution from Anne Sheets (sheets@cory)
 OBJECTID ests the arithmetic operations and various other things
 CLASS
 OBJECTID var : Int <- 0;
 OBJECTID value() : Int { var };
 OBJECTID set_var(num : Int) : SELF_TYPE {
 OBJECTID var <- num;
 OBJECTID self;
 OBJECTID method1(num : Int) : SELF_TYPE {  -- same
 OBJECTID self
 OBJECTID method2(num1 : Int, num2 : Int) : B {  -- plus
 LET
 OBJECTID x : Int in
 OBJECTID x <- num1 + num2;
 NEW
 OBJECTID set_var(x);
 OBJECTID method3(num : Int) : C {  -- negate
 LET
 OBJECTID x : Int in
 OBJECTID x <- ~num;
 NEW
 OBJECTID set_var(x);
 OBJECTID method4(num1 : Int, num2 : Int) : D {  -- diff
 IF
 OBJECTID num2 < num1 then
 LET
 OBJECTID x : Int in
 OBJECTID x <- num1 - num2;
 NEW
 OBJECTID set_var(x);
 ELSE
 LET
 OBJECTID x : Int in
 OBJECTID x <- num2 - num1;
 NEW
 OBJECTID set_var(x);
 FI
 OBJECTID method5(num : Int) : E {  -- factorial
 LET
 OBJECTID x : Int <- 1 in
 LET
 OBJECTID y : Int <- 1 in
 WHILE
 OBJECTID y <= num loop
 OBJECTID x <- x * y;
 OBJECTID y <- y + 1;
 POOL
 NEW
 OBJECTID set_var(x);
 CLASS
 INHERITS
 '-' 
 '-' 
 OBJECTID is a number squared
 OBJECTID method5(num : Int) : E { -- square
 LET
 OBJECTID x : Int in
 OBJECTID x <- num * num;
 NEW
 OBJECTID set_var(x);
 CLASS
 INHERITS
 OBJECTID method6(num : Int) : A { -- negate
 LET
 OBJECTID x : Int in
 OBJECTID x <- ~num;
 NEW
 OBJECTID set_var(x);
 OBJECTID method5(num : Int) : E {  -- cube
 LET
 OBJECTID x : Int in
 OBJECTID x <- num * num * num;
 NEW
 OBJECTID set_var(x);
 CLASS
 INHERITS
 OBJECTID method7(num : Int) : Bool {  -- divisible by 3
 LET
 OBJECTID x : Int <- num in
 IF
 OBJECTID x < 0 then method7(~x) else
 IF
 INT_CONST 0
 OBJECTID x then true else
 IF
 INT_CONST 1
 OBJECTID x then false else
 IF
 INT_CONST 2
 OBJECTID x then false else
 OBJECTID method7(x - 3)
 FI
 FI
 FI
 FI
 CLASS
 INHERITS
 OBJECTID method6(num : Int) : A {  -- division
 LET
 OBJECTID x : Int in
 OBJECTID x <- num / 8;
 NEW
 OBJECTID set_var(x);
 OBJECTID he following code is from atoi.cl in ~cs164/examples *)
 OBJECTID he class A2I provides integer-to-string and string-to-integer
 OBJECTID conversion routines.  To use these routines, either inherit them
 IN
 OBJECTID the class where needed, have a dummy variable bound to
 OBJECTID something of type A2I, or simpl write (new A2I).method(argument).
 OBJECTID c2i   Converts a 1-character string to an integer.  Aborts
 IF
 OBJECTID the string is not "0" through "9"
 CLASS
 INT_CONST 2
 OBJECTID c2i(char : String) : Int {
 IF
 OBJECTID char = "0" then 0 else
 IF
 OBJECTID char = "1" then 1 else
 IF
 OBJECTID char = "2" then 2 else
 IF
 OBJECTID char = "3" then 3 else
 IF
 OBJECTID char = "4" then 4 else
 IF
 OBJECTID char = "5" then 5 else
 IF
 OBJECTID char = "6" then 6 else
 IF
 OBJECTID char = "7" then 7 else
 IF
 OBJECTID char = "8" then 8 else
 IF
 OBJECTID char = "9" then 9 else
 OBJECTID abort(); 0; }  (* the 0 is needed to satisfy the
 OBJECTID typchecker *)
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 OBJECTID i2c is the inverse of c2i.
 OBJECTID i2c(i : Int) : String {
 IF
 OBJECTID i = 0 then "0" else
 IF
 OBJECTID i = 1 then "1" else
 IF
 OBJECTID i = 2 then "2" else
 IF
 OBJECTID i = 3 then "3" else
 IF
 OBJECTID i = 4 then "4" else
 IF
 OBJECTID i = 5 then "5" else
 IF
 OBJECTID i = 6 then "6" else
 IF
 OBJECTID i = 7 then "7" else
 IF
 OBJECTID i = 8 then "8" else
 IF
 OBJECTID i = 9 then "9" else
 OBJECTID abort(); ""; }  -- the "" is needed to satisfy the typchecker
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 OBJECTID a2i converts an ASCII string into an integer.  The empty string
 OBJECTID is converted to 0.  Signed and unsigned strings are handled.  The
 OBJECTID method aborts if the string does not represent an integer.  Very
 OBJECTID long strings of digits produce strange answers because of arithmetic 
 OBJECTID overflow.
 OBJECTID a2i(s : String) : Int {
 IF
 OBJECTID s.length() = 0 then 0 else
 IF
 OBJECTID s.substr(0,1) = "-" then ~a2i_aux(s.substr(1,s.length()-1)) else
 IF
 OBJECTID s.substr(0,1) = "+" then a2i_aux(s.substr(1,s.length()-1)) else
 OBJECTID a2i_aux(s)
 FI
 FI
 FI
 OBJECTID a2i_aux converts the usigned portion of the string.  As a
 OBJECTID programming example, this method is written iteratively.  *)
 OBJECTID a2i_aux(s : String) : Int {
 LET
 BOOL_CONST false
 BOOL_CONST false
 '-' 
 INT_CONST 0
 IN
 LET
 OBJECTID j : Int <- s.length() in
 LET
 OBJECTID i : Int <- 0 in
 WHILE
 OBJECTID i < j loop
 BOOL_CONST false
 '-' 
 BOOL_CONST false
 INT_CONST 10
 OBJECTID c2i(s.substr(i,1));
 OBJECTID i <- i + 1;
 POOL
 BOOL_CONST false
 OBJECTID i2a converts an integer to a string.  Positive and negative 
 OBJECTID numbers are handled correctly.  *)
 OBJECTID i2a(i : Int) : String {
 IF
 OBJECTID i = 0 then "0" else 
 IF
 INT_CONST 0
 OBJECTID i then i2a_aux(i) else
 '-' 
 OBJECTID concat(i2a_aux(i * ~1)) 
 FI
 FI
 OBJECTID i2a_aux is an example using recursion.  *)		
 OBJECTID i2a_aux(i : Int) : String {
 IF
 OBJECTID i = 0 then "" else 
 LET
 OBJECTID next : Int <- i / 10 in
 OBJECTID i2a_aux(next).concat(i2c(i - next * 10))
 FI
 CLASS
 OBJECTID ain inherits IO {
 OBJECTID char : String;
 OBJECTID avar : A; 
 OBJECTID a_var : A;
 OBJECTID flag : Bool <- true;
 OBJECTID menu() : String {
 OBJECTID out_string("\n\tTo add a number to ");
 OBJECTID print(avar);
 OBJECTID out_string("...enter a:\n");
 OBJECTID out_string("\tTo negate ");
 OBJECTID print(avar);
 OBJECTID out_string("...enter b:\n");
 OBJECTID out_string("\tTo find the difference between ");
 OBJECTID print(avar);
 OBJECTID out_string("and another number...enter c:\n");
 OBJECTID out_string("\tTo find the factorial of ");
 OBJECTID print(avar);
 OBJECTID out_string("...enter d:\n");
 OBJECTID out_string("\tTo square ");
 OBJECTID print(avar);
 OBJECTID out_string("...enter e:\n");
 OBJECTID out_string("\tTo cube ");
 OBJECTID print(avar);
 OBJECTID out_string("...enter f:\n");
 OBJECTID out_string("\tTo find out if ");
 OBJECTID print(avar);
 OBJECTID out_string("is a multiple of 3...enter g:\n");
 OBJECTID out_string("\tTo divide ");
 OBJECTID print(avar);
 OBJECTID out_string("by 8...enter h:\n");
 OBJECTID out_string("\tTo get a new number...enter j:\n");
 OBJECTID out_string("\tTo quit...enter q:\n\n");
 OBJECTID in_string();
 OBJECTID prompt() : String {
 OBJECTID out_string("\n");
 OBJECTID out_string("Please enter a number...  ");
 OBJECTID in_string();
 OBJECTID get_int() : Int {
 LET
 OBJECTID z : A2I <- new A2I in
 LET
 OBJECTID s : String <- prompt() in
 OBJECTID z.a2i(s)
 OBJECTID is_even(num : Int) : Bool {
 LET
 OBJECTID x : Int <- num in
 IF
 OBJECTID x < 0 then is_even(~x) else
 IF
 INT_CONST 0
 OBJECTID x then true else
 IF
 INT_CONST 1
 OBJECTID x then false else
 OBJECTID is_even(x - 2)
 FI
 FI
 FI
 OBJECTID class_type(var : A) : SELF_TYPE {
 CASE
 OBJECTID var of
 OBJECTID a : A => out_string("Class type is now A\n");
 OBJECTID b : B => out_string("Class type is now B\n");
 OBJECTID c : C => out_string("Class type is now C\n");
 OBJECTID d : D => out_string("Class type is now D\n");
 OBJECTID e : E => out_string("Class type is now E\n");
 OBJECTID o : Object => out_string("Oooops\n");
 ESAC
 OBJECTID print(var : A) : SELF_TYPE {
 LET
 OBJECTID z : A2I <- new A2I in
 OBJECTID out_string(z.i2a(var.value()));
 OBJECTID out_string(" ");
 OBJECTID main() : Object {
 OBJECTID avar <- (new A);
 WHILE
 OBJECTID flag loop
 '-' 
 '-' 
 OBJECTID avar <- (new A).set_var(get_int());
 OBJECTID out_string("number ");
 OBJECTID print(avar);
 IF
 OBJECTID is_even(avar.value()) then
 OBJECTID out_string("is even!\n")
 ELSE
 OBJECTID out_string("is odd!\n")
 FI
 '-' 
 '-' 
 OBJECTID print(avar); -- prints out answer
 OBJECTID class_type(avar);
 OBJECTID char <- menu();
 IF
 OBJECTID char = "a" then -- add
 OBJECTID a_var <- (new A).set_var(get_int());
 OBJECTID avar <- (new B).method2(avar.value(), a_var.value());
 ELSE
 IF
 OBJECTID char = "b" then -- negate
 CASE
 OBJECTID avar of
 OBJECTID c : C => avar <- c.method6(c.value());
 OBJECTID a : A => avar <- a.method3(a.value());
 OBJECTID o : Object => {
 OBJECTID out_string("Oooops\n");
 OBJECTID abort(); 0;
 ESAC
 ELSE
 IF
 OBJECTID char = "c" then -- diff
 OBJECTID a_var <- (new A).set_var(get_int());
 OBJECTID avar <- (new D).method4(avar.value(), a_var.value());
 ELSE
 IF
 OBJECTID char = "d" then avar <- (new C)@A.method5(avar.value()) else
 '-' 
 '-' 
 OBJECTID factorial
 IF
 OBJECTID char = "e" then avar <- (new C)@B.method5(avar.value()) else
 '-' 
 '-' 
 OBJECTID square
 IF
 OBJECTID char = "f" then avar <- (new C)@C.method5(avar.value()) else
 '-' 
 '-' 
 OBJECTID cube
 IF
 OBJECTID char = "g" then -- multiple of 3?
 IF
 NEW
 OBJECTID method7(avar.value()))
 THEN
 '-' 
 '-' 
 OBJECTID avar <- (new A).method1(avar.value())
 OBJECTID out_string("number ");
 OBJECTID print(avar);
 OBJECTID out_string("is divisible by 3.\n");
 ELSE
 '-' 
 '-' 
 OBJECTID avar <- (new A).set_var(0)
 OBJECTID out_string("number ");
 OBJECTID print(avar);
 OBJECTID out_string("is not divisible by 3.\n");
 FI
 ELSE
 IF
 OBJECTID char = "h" then 
 LET
 OBJECTID x : A in
 OBJECTID x <- (new E).method6(avar.value());
 LET
 OBJECTID r : Int <- (avar.value() - (x.value() * 8)) in
 OBJECTID out_string("number ");
 OBJECTID print(avar);
 OBJECTID out_string("is equal to ");
 OBJECTID print(x);
 OBJECTID out_string("times 8 with a remainder of ");
 LET
 OBJECTID a : A2I <- new A2I in
 OBJECTID out_string(a.i2a(r));
 OBJECTID out_string("\n");
 '-' 
 '-' 
 OBJECTID end let a:
 '-' 
 '-' 
 OBJECTID end let r:
 OBJECTID avar <- x;
 '-' 
 '-' 
 OBJECTID end let x:
 ELSE
 IF
 OBJECTID char = "j" then avar <- (new A)
 ELSE
 IF
 OBJECTID char = "q" then flag <- false
 ELSE
 OBJECTID avar <- (new A).method1(avar.value()) -- divide/8
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 FI
 POOL